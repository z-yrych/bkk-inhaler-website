import { NextApiResponse } from 'next';
import { ZodError } from 'zod';
import dbConnect from '@/lib/dbConnect';
import Product from '@/lib/models/Product'; // Assuming IProduct is part of Product.ts or imported separately
import {
  ProductCreationSchema,
  ProductCreationInput,
} from '@/lib/validators/productValidators';
import {
  withAdminAuth,
  NextApiRequestWithAdmin,
} from '@/lib/middleware/authMiddleware';

async function handler(
  req: NextApiRequestWithAdmin,
  res: NextApiResponse
) {
  await dbConnect();

  switch (req.method) {
    case 'POST':
      try {
        // req.adminUser is available here if needed for logging, etc.
        const validatedData = ProductCreationSchema.parse(req.body as ProductCreationInput);

        // The slug will be auto-generated by the Mongoose pre-save hook from validatedData.name
        // Price is already validated as an integer (cents) by Zod.
        const newProduct = new Product({
          ...validatedData,
          // Ensure any transformations or defaults not covered by Zod are applied if necessary
          // e.g., if images needed specific server-side processing beyond URL validation.
        });

        await newProduct.save();

        return res
          .status(201)
          .json({ message: 'Product created successfully.', product: newProduct });

      } catch (error) {
        if (error instanceof ZodError) {
          return res
            .status(400)
            .json({ message: 'Validation failed.', errors: error.errors });
        }
        // Handle Mongoose duplicate key error for slug if it somehow occurs despite auto-generation
        // (e.g., if two products with extremely similar names are created nearly simultaneously
        // and slugify produces the same result before one is saved - rare).
        if (error instanceof Error && (error as any).code === 11000 && (error as any).keyPattern?.slug) {
            return res.status(409).json({ message: 'A product with a similar name resulting in a duplicate slug already exists. Please try a slightly different name.' });
        }
        console.error('Product Creation Error:', error);
        return res
          .status(500)
          .json({ message: 'Internal Server Error creating product.' });
      }

    case 'GET':
      try {
        // For admin, list all products (active and inactive)
        // Sort by newest first
        const products = await Product.find({}).sort({ createdAt: -1 });

        // (Future: Implement pagination)
        // const page = parseInt(req.query.page as string) || 1;
        // const limit = parseInt(req.query.limit as string) || 10;
        // const skip = (page - 1) * limit;
        // const products = await Product.find({}).sort({ createdAt: -1 }).skip(skip).limit(limit);
        // const totalProducts = await Product.countDocuments({});
        // return res.status(200).json({
        //   products,
        //   currentPage: page,
        //   totalPages: Math.ceil(totalProducts / limit),
        //   totalProducts,
        // });

        return res.status(200).json({ products });
      } catch (error) {
        console.error('List Products Error:', error);
        return res
          .status(500)
          .json({ message: 'Internal Server Error fetching products.' });
      }

    default:
      res.setHeader('Allow', ['GET', 'POST']);
      return res
        .status(405)
        .json({ message: `Method ${req.method} Not Allowed` });
  }
}

export default withAdminAuth(handler);